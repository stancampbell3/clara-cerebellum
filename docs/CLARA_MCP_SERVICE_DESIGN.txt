 MCP Adapter Architecture Plan

  Phase 1: Foundation

  1. Create MCP Adapter Crate
  - New crate: clips-mcp-adapter
  - Will be a standalone process that speaks MCP JSON-RPC over stdin/stdout
  - Can connect to REST API on localhost (or embedded)

  2. Define MCP Tools (Tools exposing CLIPS functionality)
  - clips.eval - Execute CLIPS expressions
  - clips.assert - Add facts
  - clips.query - Query facts
  - clips.rules - List or query rules
  - clips.reset - Reset engine state
  - clips.status - Get engine status/facts count

  3. JSON Schema Definitions
  - Input schemas for each tool (what parameters LLM needs to provide)
  - Output schemas (what LLM receives back)
  - Error response schemas

  Phase 2: MCP Manifest & Integration

  1. mcp.json Manifest
  - Service metadata (name: "clara-clips", version, description)
  - Tool definitions with JSON schemas
  - Capabilities declaration
  - Transport configuration (stdin/stdout)

  2. MCP JSON-RPC Implementation
  - Request handler for:
    - initialize - handshake
    - tools/list - advertise available tools
    - tools/call - execute tool with parameters
  - Response wrapper following MCP spec
  - Error handling with proper MCP error codes

  Phase 3: REST API Integration

  1. HTTP Client Layer
  - Make async HTTP calls to clara-api (localhost:8080)
  - Handle session management
  - Translate MCP tool calls → REST endpoints

  2. Session Strategy
  - MCP session = Clara session
  - Each MCP client gets its own Clara session (isolation)
  - Or single shared session (simpler for development)

  Phase 4: Testing & Deployment

  1. Entry Point
  - Binary that listens on stdin/stdout
  - Reads JSON-RPC requests, writes responses
  - Can run as subprocess from Claude or other MCP clients

  2. Configuration
  - Environment variables for REST API URL
  - Optional embedded mode (spawn clara-api internally)

  ---
  Proposed Implementation Order

  1. Create crate structure - cargo new clips-mcp-adapter
  2. Implement JSON-RPC server - basic MCP request/response handling
  3. Implement 2-3 core tools (clips.eval, clips.query, clips.reset)
  4. Write JSON schemas - describe inputs/outputs
  5. Create mcp.json manifest - advertise capabilities
  6. Integration testing - test with MCP client library
  7. Documentation - how to use with Claude/other LLMs

  ---
  Key Design Decisions

  Q1: Transport?
  - A: Start with stdin/stdout (most compatible), WebSocket later

  Q2: Session Management?
  - A: MCP adapter creates one Clara session at startup, reuses it
    - Simpler for LLM stateful interactions
    - Can add multi-session later if needed

  Q3: Error Handling?
  - A: Map CLIPS errors → MCP error responses with descriptive messages

  Q4: REST vs Embedded?
  - A: Connect to REST API initially (clara-api already running)
  - Can add embedded mode later (spawn clara-api from adapter)

  ---

