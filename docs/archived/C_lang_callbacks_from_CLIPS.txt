CLIPS ↔ Rust Callback Integration Guide

This document explains how to register a C-style callback in CLIPS that synchronously invokes Rust code, performs an operation, and returns JSON.

1. Rust Side: Expose Callback

#[no_mangle]
pub extern "C" fn rust_callback(input: *const libc::c_char) -> *mut libc::c_char {
    // Convert C string to Rust string
    let c_str = unsafe { std::ffi::CStr::from_ptr(input) };
    let input_str = c_str.to_str().unwrap_or("");

    // Perform synchronous operation (MCP logic)
    let result_json = serde_json::json!({
        "status": "ok",
        "input": input_str,
        "data": "example result"
    });

    // Convert Rust String -> C string
    let output = std::ffi::CString::new(result_json.to_string()).unwrap();
    output.into_raw()
}

#[no_mangle]
pub extern "C" fn rust_free(s: *mut libc::c_char) {
    if s.is_null() { return; }
    unsafe { let _ = std::ffi::CString::from_raw(s); }
}

Notes

rust_callback receives a C string, processes it, and returns a JSON string.

rust_free ensures memory allocated in Rust is properly released.

2. C Side: Declare Rust Functions

extern char* rust_callback(const char* input);
extern void rust_free(char* s);

3. CLIPS Integration

Register the callback with CLIPS using DefineFunction2:

#include "clips.h"

void CallRustFunction(void* env) {
    const char* arg = GetLexemeValue(GetFirstArgument(env));
    char* result = rust_callback(arg);

    // Return JSON string back to CLIPS
    SetEvaluationError(env, FALSE);
    SetReturnValue(env, CreateString(env, result));

    rust_free(result); // free memory allocated in Rust
}

void RegisterRustCallback(void* env) {
    DefineFunction2(env,
        "rust-call",              // CLIPS function name
        's',                      // return type: string
        PTIEF CallRustFunction,   // C function pointer
        "CallRustFunction",       // pretty name
        "11s");                   // argument signature: 1 string
}

4. Usage in CLIPS

(rust-call "some input")

This will synchronously invoke Rust logic and return a JSON string.

5. Best Practices

Memory Management: Always free strings returned from Rust.

Error Handling: Return JSON error objects if Rust fails.

Thread Safety: Keep callbacks synchronous unless explicitly managed.

✅ Example Flow

CLIPS (rust-call "foo")

CLIPS → C shim → Rust FFI

Rust MCP server logic runs, returns JSON string

JSON string flows back into CLIPS as a string result

This scaffold ensures reproducibility and clarity for onboarding teammates.